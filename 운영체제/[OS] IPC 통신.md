## Inter-Process Communication (프로세스 간 통신)

![image](https://github.com/LeeHyogon/cs-/assets/45483116/44b16b3d-801b-403b-873c-f3725bb84470)


### 1. 프로세스 간 통신 종류

- 프로세스 내부 데이터 통신: 하나의 프로세스 내 2개 이상의 스레드가 존재하는 경우. 프로세스 내부의 스레드는 전역 변수나 파일을 이용하여 데이터를 주고 받음
- 프로세스 간 데이터 통신: 같은 컴퓨터에 있는 여러 프로세스끼리 통신, 공용파일 또는 OS가 제공하는 파이프를 사용하여 통신
- 네트워크를 이용한 데이터 통신: 여러 컴퓨터가 네트워크로 연결되어 있을 때 소켓을 이용하여 통신. 이처럼 소켓을 이용하는 프로세스 간 통신을 **네트워킹**이라고 함. 다른 컴퓨터에 있는 함수 호출하여 통신하는 원격 프로시저 호출(RPC)도 여기 해당


### 2. 프로세스 간 통신의 분류


### 2.1 통신 방향 분류
- 양방향 통신: 데이터를 동시에 양쪽 방향으로 전송하는 구조. 소켓 통신
- 반양방향 통신: 동시 전송이 불가능한 특정 시점에 한쪽 방향으로 전송할 수 있는 구조. 무전기
- 단방향 통신: 모스 신호처럼 한쪽 방향으로만 데이터를 전송할 수 있는 구조. 프로세스 간 통신에는 전역 변수와 파이프가 단방향 통신에 해당

전역 변수를 1개만 이용하면, 단방향 통신. 전역 변수 2개는 양방향 통신 가능

### 2.2 통신 구현 방식 분류

#### 전역 변수 사용 통신 방식의 문제점
- 데이터를 언제 보낼지 받는쪽이 알 수 없음.
- 데이터 받는 쪽에서 반복적인 체크가 필요. **(Busy Waiting)**
#### 해결방안
- 데이터가 도착했음을 알려주는 동기화를 사용한다.

- **Blocking communication**: 동기화를 지원하는 통신 방식. 데이터를 받는 쪽은 데이터가 도착할 때까지 대기 상태. (파이프, 소켓)
- **Non-Blocking communication**: 동기화 지원하지 않는 통신 방식. 데이터를 받는 쪽은 busy waiting을 사용하여 데이터 도착 여부를 확인한다. (전역변수, 파일)

### 프로세스 간 통신 종류

#### 2.1 전역 변수를 이용한 통신

- 전역 변수를 이용한 통신은 공동 관리 메모리를 이용. 데이터를 보내는 쪽에서 전역 변수나 파일에 값을 쓰고, 데이터를 받는 쪽에서 전역 변수의 값을 읽음.
![image](https://github.com/LeeHyogon/cs-/assets/45483116/1b51d78c-cff0-482e-a197-0a6798d8fe68)

- 전역 변수 2개를 사용하여 양방향 통신 구현
- fork()로 만들어진 프로세스는 전역 변수 R이 바뀔 때까지 작동하지 않고 check만 반복하는 **busy waiting**에 빠지는 단점이 있음.

#### 2.2 파일을 이용한 통신

``` c++
int main(){
    int fd;
    char buf[5];

    fd = open('com.txt', O_RDWR);
    write(fd, "test", 5);
    read(fd, buf, 5);
    close(fd);
}
```
![image](https://github.com/LeeHyogon/cs-/assets/45483116/d443140a-8284-4932-8f5a-bd06d20c2b61)

- 입출력은 다음과 같이 입출력 프로세스가 따로 존재하여 관리. OS의 입장에서는 저장장치의 데이터를 read write하는 것도 일반 프로세스와 입출력 프로세스 간의 통신으로 봄.
- 파일을 이용한 통신은 부모-자식 프로세스 간 통신에 많이 사용. OS가 프로세스 동기화를 제공하지 않음. 그래서 부모 프로세스가 wait()함수를 이용하여 자식 프로세스의 작업이 끝날때까지 기다리고 작업을 시작.

#### 2.3 파이프를 이용한 통신
![image](https://github.com/LeeHyogon/cs-/assets/45483116/8ff0cf39-eda1-4fc4-bca8-1abdc2cb72d7)

- 파이프는 OS가 제공하는 동기화 통신 방식. 파일 입출력과 같이 Open()함수로 descripter를 받고 작업 후에 close로 마무리. 파이프 이용 통신은 전역 통신과 마찬가지로 단방향 통신. 양방향 통신을 위해서는 2개를 사용해야 함
- 파이프는 queue와 같다. 한쪽에서는 write(push)하고 한쪽에서는 read(pop) 밖에 할 수 없다. 만약 프로세스 B가 파이프 1에 대해 읽기 연산을 수행했는데 프로세스 A가 파이프 1에 쓰기 연산을 하지 않았다면 프로세스B는 대기 상태가 된다. 이러한 대기 상태는 프로세스 A가 파이프 1에 write하면 풀려 동기화가 이뤄진다.
- **busy waiting**이 자원을 더 많이 소모하는 이유는 단순 wait(block)상태가 아닌 계속해서 체크해야 하므로 타임 슬라이스를 얻어 run, ready 상태를 반복하기 때문.

#### 파이프 종류
- anonymoun pipe: 일반적인 파이프. 부모와 자식 혹은 같은 부모의 자식프로세스처럼 서로 관련있는 프로세스 간 통신에 사용. 단방향 통신
- named pipe: FIFO라는 특수 파일을 이용하여 서로 관련 없는 프로세스 간 통신에 사용. 양방향 통신 가능하고 관계 필요x
  

#### 2.4 소켓 통신
![image](https://github.com/LeeHyogon/cs-/assets/45483116/3b5e7e22-fd24-4ef2-ae8e-177f9f181ce3)
- 하나만 사용해도 양방향 통신 가능
- 네트워크의 기본은 소켓이므로, 네트워크 프로그래밍을 소켓 프로그래밍이라고도 함
- **원격 프로시저 호출**(RPC)는 다른 컴퓨터에 있는 함수를 호출하는 것
- 다른 컴퓨터에 있는 프로세스와 통신하려면 그 컴퓨터의 위치를 파악하고 원격지의 시스템 내 여러 프로세스 중 어떤 프로세스와 통신 할지 결정해야 함.

### 요약 

![image](https://github.com/LeeHyogon/cs-/assets/45483116/9fe5b42f-2421-4f78-a7b7-e563e6a07c2d)

- 여기서의 동기화는 데이터가 도착했음을 알려주는 것을 의미.(알람같은). 공유자원의 동기화와 다름

ref: https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-7%ED%8E%B8-IPC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84-%ED%86%B5%EC%8B%A0
