db 인덱스

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치.

인덱스는 보통 B-트리라는 자료 구조.

** 인덱스르 만드는 방법**
MySQL의 경우 클러스터형 인덱스와 세컨더리 인덱스가 있다.

클러스터형 인덱스는 테이블 당 하나를 설정할 수 있다.
하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스 보다 성능이 좋다.

세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스입니다.

예를들어 age라는 하나의 필드만으로 쿼리를 보낸다면 클러스터형 인덱스만 필요.

age,name,email 등 다양한 필드를 기반으로 쿼리를 보낼 때는 세컨더리 인덱스를 사용해야 합니다.

**인덱스 최적화 기법 **

인덱스는 비용이다.
인덱스는 두번 탐색하도록 강요합니다. 인덱스 리스트, 그다음 컬렉션 순으로 탐색하기 때문이며, 관련 읽기 비용이 들게 됩니다.

또한, 컬렉션이 수정되었을 때 인덱스도 수정되어야 합니다. 


항상 테스트하라(expain()함수를 통해 인덱스르 만들고 쿼리를 보낸이후에 테스팅)

복합인덱스는 같음, 정렬 다중 값, 카디널리티 순이다.
보통 여러 필드를 기반으로 조회를 할 때 복합 인덱스르 ㄹ생성하는데, 이 인덱스를 생성할때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라집니다ㅣ.
같음,정렬,다중값, 카디널리티 순으로 생성해야 합니다.

1. 어떠한 값과 같음을 비교하는 == 이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정.

2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정합니다.

3. 다중 값을 출력해야 하는 필드,즉 쿼리 자체가 > 이거나 < 등 많은 값을 출력해야하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정합니다.

4. 유니크한 값의 정도를 카디널리티라고 합니다. 이 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야 합니다. 예를들어 age,email이 있으면 email이라는 필드에 대한 
인덱스를 먼저 생성해야함.


=========================================

인덱스를 보통 왜 사용하나요?
인덱스는 db성능 향상 수단으로 사용되는 가장 일반적인 방법입니다.
응답 시간이 늦은 SQL이 발견되면 우선 인덱스로 해결할 수 없는지를 검사하는 것이 튜닝의 제 1선택입니다.

인덱스의 장점으로는 SQL 문을 변경하지 않아도 성능을 개선할 수 있다는 점과, 테이블의 데이터에 영향을 주지 않는다는 점이 있습니다.

단점으로는 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제 수정하는 경우에는 쿼리문 실행 속도가 느려진다.
결론적으로 인덱스는 데이터의 저장 성능을 희생하고, 그 대신 데이터의 읽기 속도를ㄹ 높이는 기능. 
SELECT 쿼리 문장 WHERE조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

===========================================
보통 INDEX를 어느 컬럼에 걸어주나요?

보통 Cardinality(카디널리티)가 높은 열에 만듭니다.

Cardinality란 값의 분산도를 나타내는 단어로, 특정 열에 대해 많은 종류의 값을 가지고 있다면, Cardinality가 높다는 의미입니다.

그리고 크기가 큰 테이블에 만듭니다.

제 경험으로 미루어 봤을 때 row수가 약 80만 건 정도가 되면 인덱스가 없는 조회는 성능이 떨어졌습니다.

===================================================

테이블의 크기가 크다의 기준은 무엇인가요??

일평균 5000건 이상씩 생성되는 주문 테이블을 크다고 판단하고 인덱스를 걸어주었습니다.

===================================================

INDEX가 Hash가 아닌 B-tree를 사용하는 이유
SELECT의 질의의 조건에는 부등호 연산도 포함이 됩니다.
동등 연산에 특화된 해쉬는 DB자료구조로 적합하지 않습니다.

=====================================================

distinct vs group by

Distinct vs group by
Distinct는 중복된 결과를 제거하여 유일한 결과만 반환.
반면에 group by는 데이터를 그룹화 하고 그룹화된 결과를 반환합니다.
====================================================

B-Tree 
장점- 어떤 데이터를 조회하든지, 이에 사용하는 조회 과정의 길이 및 비용이 균등

Hash 인덱스 알고리즘
칼럼의값으로 해쉬 값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색을 지원하지만 범위검색이 불가능.

	   클러스터 인덱스  	   				보조 인덱스(세컨더리 인덱스)

속도 	    빠르다 		    	 			느리다
메모리 	적다		  	     	  			많다
인덱스   인덱스주요데이터	   				인덱스가 데이터의 사본
개수		한테이블에 한개     	  			한테이블에 여러 개
리프노드    리프노자체가 데이터     			리프 노드는 데이터가 저장되는 위치
정렬     인덱스 순서와 물리적순서 일치    	인덱스 순서와 물리적 순서가 불일치

==================================
클러스터 인덱스
특정 나열된 데이터들을 일정 기준으로 정렬해주는 인덱스

한개의 테이블에 한개씩만 만들 수 있다.(ex: Primary Key)

본래 인덱스는 생성 시 데이터들의 배열정보를 따로 저장하는 공간을 사용하나, 클러스터 인덱스는 따로 저장하는 정보 공간을 적게 사용하면서
테이블의 공간 자체를 활용
인덱스 자체의 리프 페이지가 곧 데이터이기 때문에 인덱스 자체에 데이터가 포함되어있다고 볼 수 있다.

보조 인덱스보다 검색 속도는 더 빠르다.
하지만 입력/수정/삭제는 더 느리다.

MySQL에서는 Primary Key가 있다면 Primary Key를 Clustered INDEX로, 없다면 UNIQUE하면서 NOT NULL인 컬럼을, 그것도 없으면 임의로 보이지 않느 컬럼을 만들어
Clustered Index로 지정한다.

클러스터 인덱스 생성시 페이지 변화

인덱싱을하면 루트페이지 라는 것이 만들어진다.










