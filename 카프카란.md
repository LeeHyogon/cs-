## Apache Kafka
- 고성능 데이터 파이프라인, 스트리밍 분석, 데이터 통합 및 및 미션 크리티컬 애플리케이션을 위해 설계된
고성능 분산 이벤트 스트리밍 플랫폼
- Pub-Sub 모델의 메시지 큐 형태로 동작하며 분산환경에 특화

#### 장점
- 모든 이벤트/데이터의 흐름을 중앙에서 관리
- 새로운 서비스/시스템이 추가되도 카프카가 제공하는 표준 포맷으로 연결하면 되므로 확장성/신뢰성 증가
- 개발자는 각 서비스간의 연결이 아닌, 서비스들의 비즈니스 로직에 집중 가능

### 카프카의 동작 방식 및 특징

#### 메세지 큐 (Message Queue, MQ)란?
- 메시지 큐는 메시지 지향 미들웨어를 구현한 시스템으로 프로그램(프로세스)간의 데이터를 교환할 때 사용하는 기술

Producer - Message Queue(Broker) - Consumer

### 용어 정리
- producer: 정보를 제공하는 자
- consumer: 정보를 제공받아서 사용하려는 자
- Queue: producer의 데이터를 임시 저장 및 consumer에 제공하는 곳

MQ에서는 메세지는 Endpoint간에 직접적으로 통신x, Queue를 통해 중개된다.

#### Message Queue 장점
- 비동기: queue라는 임시 저장소가 있기 때문에 나중에 처리 가능
- 낮은 결합도: 애플리케이션과 분리
- 확장성: producer or consumer 서비스를 원하는대로 확장 가능
- 탄력성: consumer 서비스가 다운되더라도 애플리케이션 중단되는 것은 아니며 메세지 지속하여 MQ에 남아있음
- 보장성: MQ에 들어간다면 결국 모든 메시지가 consumer 서비스에게 전달된다는 보장
### 메세지 브로커/ 이벤트 브로커

#### 메세지 브로커
- publisher가 생성한 메세지를 메세지 큐에저장하고, 저장된 데이터를 consumer가 가져갈 수 있도록 하는 중간 다리
- 보통 서로 다른 시스템(혹은 sw) 사이에서 데이터를 비동기 형태로 처리하기 위해 사용
- 이러한 구조를 pub/sub 구조라고 하며 대표적으로 Redis, RabbitMQ 소프트웨어 emddl dlTDma
- 이와 같은 메세지 브로커들은 consumer가 큐에서 데이터를 가져가게 되면 즉시 혹은 짧은 시간 내에 큐에서 데이터가 삭제되는 특징이 있음

#### 이벤트 브로커
- 기본적으로 메세지 브로커의 큐 기능들을 가지고 있어 메세지 브로커 역할 가능
- 차이점은 이벤트 브로커는 publisher가 생산한 이벤트를 이벤트 처리 후에 바로 삭제하지 않고 저장하여, 이벤트 시점이 저장되어 있어서 
- consumer가 특정 시점부터 이벤트를 다시 consume할 수 있는 장점이 있다.
- 또한 대용량 처리에 있어서는 메세지 브로커보다는 더 많은 양의 데이터를 처리할 수 있는 능력이 있음.
- 이벤트 브로커에는 Kafka,AWS의 kinesis 같은 서비스가 있다.

#### 일반적인 형태의 네트워크 통신(end-to-end)
- 각 개체가 직접 연결하며 통신하게 된다.
- 전송속도가 빠르고 전송 결과를 신속하게 알 수 있음
- 특정 개체에 장애가 발생한 경우 메세지를 보내는 쪽에서 대기 처리 등을 개별적으로 해주지 않으면 장애 전파 가능성
- 또한, 참여 개체가 많아질 수록 각 개체를 연결해줘야함(확장성이 좋지않다.)

#### Pub/Sub 모델
- 비동기 메세징 전송 방식, 발신자의 메세지는 수신자가 정해져 있지 않은 상태로 publish
- 이를 Subscribe(구독)을 한 수신자만 정해진 메세지(topic)을 받을 수 있다.
- 이처럼 **수신자는 발신자 정보** 가 없어도 원하는 메세지만 수신할 수 있으며, 이런 구조 덕분에 높은 확장성 확보
- Pub/Sub 모델의 구체적인 발행/구독 방식은 각 서비스 마다 다름

### Redis의 동작 방식 및 특징
- Reids는 DB, 캐시, 메시지 브로커 및 스트리밍 엔진으로 사용되는 인메모리 데이터 구조 저장소

#### 구성요소
- publisher
- channel
- subscriber

#### 동작
- publisher가 channel에 메세지 게시
- 해당 채널을 구독하고 있는 subscriber가 메세지를 sub해서 처리

#### 특징
- channel은 이벤트를 저장x
- channel에 이벤트가 도착했을 때 해당 채널의 subscriber가 존재하지 않는다면 이벤트 사라짐
- subscriber는 동시에 여러 channel을 구독가능, 특정 channel을 지정하지 않고 패턴을 설정하여 해당 패턴에 맞는 채널 구독 가능

#### 장점
- 처리 속도가 빠름
- 캐시 역할 가능
- 명시적으로 데이터 삭제가능
#### 단점
- 메모리 기반이므로 서버가 다운되면 데이터 유실
- 이벤트 도착 보장 못함

### Kafka의 동작 방식 및 특징

- LinkedIn에서 개발된 pub-sub 모델의 메시지 큐 방식 기반 분산 메시징 시스템

#### 구성 요소
- Event: kafka에서 producer와 consumer가 데이터를 주고 받는 단위. 메세지
- Producer: kafka에 이벤트를 게시(post, pop)하는 클라이언트 어플리케이션
- Consumer: Topic을 구독하고 이로부터 얻어낸 이벤트를 받아(Sub) 처리하는 클라이언트 어플리케이션
- Topic: 이벤트가 모이는 곳. producer는 topic에 이벤트를 게시하고, consumer는 topic을 구독해 이로부터 이벤트를 가져와 처리.
- Partition: Topic은 여러 Broker에 분산되어 저장되며, 이렇게 분산된 topic을 partition이라고 함
- Zoopeeper: 분산 메세지의 큐의 정보를 관리

#### 동작원리
- **대규모 트래픽 처리 및 분산 처리**에 효과적
- 클러스터 구성, Fail-over, Replication 같은 기능있음
- 100Kb/sec정도 속도로 다른 메세지 큐보다 빠름
- 디스크에 메세지를 특정 보관 주기동안 저장하여 데이터 영속성 보장 유실위험 적음
- Consumer 장애 시 재처리가 가능

### 카프카 구성 요소 및 특징

#### Topic
- 각각의 메시지를 목적에 맞게 구분할 때 사용
- 메시지를 전송하거나 소비할 때 Topic을 반드시 입력
- Consumer는 자신이 담당하는 Topic의 메시지를 처리
- 한 개의 토픽은 한 개 이상의 파티션으로 구성

#### Partition
- 분산 처리를 위해 사용된다.
- Topic 생성 시 partition 개수를 지정할 수 있다.
- 파티션이 1개라면 모든 메시지에 대해 순서 보장
- 파티션 내부에 각 메시지는 offset으로 구분 된다.
- 파티션이 여러 개라면 Kafka 클라서트가 라운드 로빈 방식으로 분배해서 분산처리되므로 순서 보장 X
- 파티션이 많을 수록 처리량이 좋지만 장애 복구 시간이 늘어남

#### Offset
- 컨슈머에서 메세지를 어디까지 읽었는지 저장하는 값
- 컨슈머 그룹의 컨슈머들은 각각의 파티션에 자신이 가져간 메시지의 위치 정보 기록
- 컨슈머 장애 발생 후 다시 살아나도, 전에 마지막으로 읽었던 위치에서 다시 읽어들일 수 있음

#### Producer
- 메시지를 만들어서 카프카 클러스터에 전송
- 메시지 전송 시 Batch 처리가 가능
- key값을 지정하여 특정 파티션으로만 전송이 가능
- 전송 acks값을 설정하여 효율성 높일 수 있음
- ACKS=0->빠르게 전송, 파티션 리더가 받았는지 모름
- ACKS=1->파티션 리더가 받았는지 확인, 기본값
- ACKS=ALL-> 파티션 리더 뿐 아니라 팔로워까지 메시지 수신 확인

#### Consumer
- 카프카 클러스터에서 메시지를 읽어서 처리
- 메시지를 Batch 처리가능
- 한 개의 컨슈머는 여러 개의 토픽을 처리할 수 있다
- 메시지를 소비해도 메시지를 삭제하지 않음 (Kafka delete policy에 의해 삭제)
- 컨슈머는 컨슈머 그룹에 속함
- 한 개 파티션은 같은 컨슈머 그룹의 여러 개 컨슈머에 연결할 수 없다

#### Broker
- 실행된 카프카 서버를 말함
- 프로듀서와 컨슈머는 별도의 애플리케이션으로 구성되는 반면, 브로커는 카프카 자체이다
- Broker(각 서버)는 Kafka Cluster 내부에 존재
- 서버 내부에 메시지를 저장하고 관리하는 역할을 수행

#### Zookeeper
- 분산 애플리케이션 관리를 위한 코디네이션 시스템
- 분산 메시지큐의 메타 정보를 중앙에서 관리하는 역할

### 주요 설계 특징
왜 하나의 topic을 여러 개의 partition으로 분산시키는가?

- 병렬로 처리하기 위해 분산 저장
- 카프카의 토픽에 메시지가 쓰여지는 것도 어느정도 시간이 소비됨
- 몇 천건의 메시지가 동시에 카프카에 write되면 병목현상 발생할 수 있음
- 따라서 파티션을 여러 개 두어서 분산 저장하해서 write 동작을 병렬로 처리할 수 있음
- 다만 한번 늘린 파티션은 절대 줄일 수 없음!!(최소한의 파티션 운영 권장)
- 파티션을 늘렸을 때 메세지는 Round-Robin 방식으로 쓰여짐. 순서 보장x

### 컨슈머 그룹이란?
- consumer 묶음
- 컨슈머 그룹은 하나의 topic에 대한 책임을 갖고 있다.
- 즉 어떤 consumer가 down된다면, 파티션 재조정을 통해 다른 컨슈머가 해당 파티션의 sub를 맡아서 함. 
- offset정보를 그룹간에 공유하고 있으므로, down되기 전 마지막 읽었던 메시지 위치부터 시작함


